query_name,query_subheader,query_description,csv_export,html_result,merge_df,query
databasetime,AWS SCT Report Execution Time,Current DB Time,N,Y,N,"select 'Current Database Time' as ""Current Time"", date_trunc('second', clock_timestamp()::timestamp) as ""DB Date Time"";"
sctextensions,RDS PostgreSQL DB Details,PostgreSQL Version and Existance of AWS SCT Extensions,N,Y,N,"select 'PostgreSQL' ""Engine"", current_database() ""Database Name"", trim(substr(version(), 1, 16)) ""Version"", ( select exists ( select FROM information_schema.tables WHERE table_schema like 'aws_%_ext' and table_name = 'versions' ) ) as ""SCT Oracle Extension Exists"" ;"
sctversion,AWS SCT Extension Details,AWS Extension Version Details,N,Y,N,"SELECT componentversion as ""AWS Extension Version"" FROM aws_oracle_ext.versions as extVersion;"
sctassessmentsummary,AWS Extension usage - Database Object Summary,Summary listing of all AWS Schema Conversion Tool,N,N,Y,"with alias1 as ( ( /*Default Constraint*/ with alias1 as ( select alias1.proname, ns.nspname, case when relkind = 'r' then 'TABLE' END AS objType, depend.relname, alias1.proname as def from pg_depend inner join ( select distinct pg_proc.oid as procoid, nspname || '.' || proname as proname, pg_namespace.oid from pg_namespace, pg_proc where nspname in ( 'aws_oracle_ext', 'aws_sqlserver_ext', 'aws_mysql_ext', 'aws_oracle_ext' ) and pg_proc.pronamespace = pg_namespace.oid ) alias1 on pg_depend.refobjid = alias1.procoid inner join pg_attrdef on pg_attrdef.oid = pg_depend.objid inner join pg_class depend on depend.oid = pg_attrdef.adrelid inner join pg_namespace ns on ns.oid = depend.relnamespace where ns.nspname IN ( SELECT n.nspname FROM pg_catalog.pg_namespace n WHERE n.nspname !~ '^pg_' AND n.nspname <> 'information_schema' and n.nspname !~ '^aws_' ) ), alias2 as ( select alias1.nspname as schema, alias1.relname as table_name, alias2.* from alias1 cross join lateral ( select i as funcname, cntgroup as cnt from ( select ( regexp_matches( alias1.def, 'aws_[a-z]*_ext[.][a-z]*[_,a-z,$,""]*', 'ig' ) ) [1] i, count(1) cntgroup group by ( regexp_matches( alias1.def, 'aws_[a-z]*_ext[.][a-z]*[_,a-z,$,""]*', 'ig' ) ) [1] ) t ) as alias2 where ( def ~* 'aws_(oracle|sqlserver|mysql|postgresql)_ext.*' ) ) select alias2.schema as ""DBSchema"", 'Schema' as ""Category"", 'Default Constraint' as ""Sub - Category"", alias2.funcname as ""AWS Extension Dependency"", sum(cnt) as ""SCT Function Reference Count"" from alias2 group by alias2.schema, alias2.funcname union all SELECT n.nspname as ""DBSchema"", 'Schema' as ""Category"", 'Default Constraint' as ""Sub - Category"", t.funcname as ""AWS Extension Dependency"", sum(t.cnt) as ""SCT Function Reference Count"" FROM pg_attribute a JOIN pg_class c ON c.oid = a.attrelid JOIN pg_namespace n ON n.oid = c.relnamespace LEFT OUTER JOIN pg_attrdef d ON d.adrelid = c.oid AND d.adnum = a.attnum cross join lateral ( select i as funcname, cntgroup as cnt from ( select ( regexp_matches( pg_get_expr(d.adbin, d.adrelid), 'aws_[a-z]*_ext[.][a-z]*[_,a-z,$,""]*', 'ig' ) ) [1] i, count(1) cntgroup group by ( regexp_matches( pg_get_expr(d.adbin, d.adrelid), 'aws_[a-z]*_ext[.][a-z]*[_,a-z,$,""]*', 'ig' ) ) [1] ) t ) t WHERE c.relkind IN ('r', 'v', 'm') AND a.attnum > 0 AND n.nspname NOT IN ('information_schema', 'pg_catalog') and n.nspname !~ '^aws_' AND pg_get_expr(d.adbin, d.adrelid) IS NOT NULL AND EXISTS ( SELECT regexp_matches( pg_get_expr(d.adbin, d.adrelid), 'aws_[a-z]*_ext[.][a-z]*[_,a-z,$,""]*', 'ig' ) ) group by n.nspname, t.funcname ) union all ( /*Check Constraint*/ with alias1 as ( select pgc.conname as constraint_name, ccu.table_schema as table_schema, ccu.table_name, ccu.column_name, pg_get_expr(pgc.conbin, cls.oid) as def from pg_constraint pgc join pg_namespace nsp on nsp.oid = pgc.connamespace join pg_class cls on pgc.conrelid = cls.oid left join information_schema.constraint_column_usage ccu on pgc.conname = ccu.constraint_name and nsp.nspname = ccu.constraint_schema where contype = 'c' and nsp.nspname IN ( SELECT n.nspname FROM pg_catalog.pg_namespace n WHERE n.nspname !~ '^pg_' AND n.nspname <> 'information_schema' and n.nspname !~ '^aws_' ) order by pgc.conname ), alias2 as ( select alias1.constraint_name, alias1.table_name, alias1.column_name, alias1.table_schema as schema, alias2.* from alias1 cross join lateral ( select i as funcname, cntgroup as cnt from ( select ( regexp_matches( alias1.def, 'aws_[a-z]*_ext[.][a-z]*[_,a-z,$,""]*', 'ig' ) ) [1] i, count(1) cntgroup group by ( regexp_matches( alias1.def, 'aws_[a-z]*_ext[.][a-z]*[_,a-z,$,""]*', 'ig' ) ) [1] ) t ) as alias2 where def ~* 'aws_(oracle|sqlserver|mysql|postgresql)_ext.*' ) select alias2.schema as ""DBSchema"", 'Schema' as ""Category"", 'Check Constraint' as ""Sub - Category"", alias2.funcname as ""AWS Extension Dependency"", sum(cnt) as ""SCT Function Reference Count"" from alias2 group by alias2.schema, alias2.funcname ) union all ( with alias1 as ( select alias1.proname, nspname, case when relkind = 'i' then 'INDEX' END AS objType, depend.relname, alias1.proname def from pg_depend inner join ( select distinct pg_proc.oid as procoid, nspname || '.' || proname as proname, pg_namespace.oid from pg_namespace, pg_proc where nspname ~* 'aws_(oracle|sqlserver|mysql|postgresql)_ext.*' and pg_proc.pronamespace = pg_namespace.oid ) alias1 on pg_depend.refobjid = alias1.procoid inner join pg_class depend on depend.oid = pg_depend.objid inner join pg_namespace ns on ns.oid = depend.relnamespace where ns.nspname IN ( SELECT n.nspname FROM pg_catalog.pg_namespace n WHERE n.nspname !~ '^pg_' AND n.nspname <> 'information_schema' and n.nspname !~ '^aws_' ) and relkind = 'i' ), alias2 as ( select alias1.nspname as Schema, alias1.relname as IndexName, alias2.* from alias1 cross join lateral ( select i as funcname, cntgroup as cnt from ( select ( regexp_matches( alias1.def, 'aws_[a-z]*_ext[.][a-z]*[_,a-z,$,""]*', 'ig' ) ) [1] i, count(1) cntgroup group by ( regexp_matches( alias1.def, 'aws_[a-z]*_ext[.][a-z]*[_,a-z,$,""]*', 'ig' ) ) [1] ) t ) as alias2 where def ~* 'aws_(oracle|sqlserver|mysql|postgresql)_ext.*' ) select alias2.schema as ""DBSchema"", 'Schema' as ""Category"", 'Index Expression' as ""Sub - Category"", alias2.funcname as ""AWS Extension Dependency"", sum(cnt) as ""SCT Function Reference Count"" from alias2 group by alias2.schema, alias2.funcname ) union all ( with alias1 as ( select alias1.proname, nspname, case when depend.relkind = 'v' then 'VIEW' END AS objType, depend.relname, pg_get_viewdef(depend.oid) def from pg_depend inner join ( select distinct pg_proc.oid as procoid, nspname || '.' || proname as proname, pg_namespace.oid from pg_namespace, pg_proc where nspname ~* 'aws_(oracle|sqlserver|mysql|postgresql)_ext' and pg_proc.pronamespace = pg_namespace.oid ) alias1 on pg_depend.refobjid = alias1.procoid inner join pg_rewrite on pg_rewrite.oid = pg_depend.objid inner join pg_class depend on depend.oid = pg_rewrite.ev_class inner join pg_namespace ns on ns.oid = depend.relnamespace where not exists ( select 1 from pg_namespace where pg_namespace.oid = depend.relnamespace and nspname !~ '^aws_' ) and nspname IN ( SELECT n.nspname FROM pg_catalog.pg_namespace n WHERE n.nspname !~ '^pg_' AND n.nspname <> 'information_schema' and n.nspname !~ '^aws_' ) ), alias2 as ( select alias1.nspname as Schema, alias1.relname as ViewName, alias2.* from alias1 cross join lateral ( select i as funcname, cntgroup as cnt from ( select ( regexp_matches( alias1.def, 'aws_[a-z]*_ext[.][a-z]*[_,a-z,$,""]*', 'ig' ) ) [1] i, count(1) cntgroup group by ( regexp_matches( alias1.def, 'aws_[a-z]*_ext[.][a-z]*[_,a-z,$,""]*', 'ig' ) ) [1] ) t ) as alias2 where def ~* 'aws_(oracle|sqlserver|mysql|postgresql)_ext.*' ) select alias2.schema as ""DBSchema"", 'Schema' as ""Category"", 'Views' as ""Sub-Category"", alias2.funcname as ""AWS Extension Dependency"", sum(cnt) as ""SCT Function Reference Count"" from alias2 group by alias2.schema, alias2.funcname ) union all ( with alias1 as ( select distinct n.nspname as function_schema, p.proname as function_name, l.lanname as function_language, ( select 'Y' from pg_trigger where tgfoid = p.oid limit 1 ) as Trigger_Func, lower(pg_get_functiondef(p.oid) :: text) as def from pg_proc p left join pg_namespace n on p.pronamespace = n.oid left join pg_language l on p.prolang = l.oid left join pg_type t on t.oid = p.prorettype where n.nspname not in ('pg_catalog', 'information_schema') and n.nspname IN ( SELECT n.nspname FROM pg_catalog.pg_namespace n WHERE n.nspname !~ '^pg_' AND n.nspname <> 'information_schema' and n.nspname !~ '^aws_' ) and p.prokind not in ('a', 'w') and l.lanname in ('sql', 'plpgsql') order by function_schema, function_name ), alias2 as ( select alias1.function_schema, alias1.function_name, alias1.function_language, alias1.Trigger_Func, alias2.* from alias1 cross join lateral ( select i as funcname, cntgroup as cnt from ( select ( regexp_matches( alias1.def, 'aws_[a-z]*_ext[.][a-z]*[_,a-z,$,""]*', 'ig' ) ) [1] i, count(1) cntgroup group by ( regexp_matches( alias1.def, 'aws_[a-z]*_ext[.][a-z]*[_,a-z,$,""]*', 'ig' ) ) [1] ) t ) as alias2 where def ~* 'aws_(oracle|sqlserver|mysql|postgresql)_ext.*' and Trigger_Func = 'Y' ) select function_schema as ""DBSchema"", 'Procedural' as ""Category"", 'Trigger-Functions' as ""Sub-Category"", funcname as ""AWS Extension Dependency"", sum(cnt) as ""SCT Function Reference Count"" from alias2 where 1 = 1 group by function_schema, funcname order by 3, 4 desc ) union all ( with alias1 as ( select distinct n.nspname as function_schema, p.proname as function_name, l.lanname as function_language, ( select 'Y' from pg_trigger where tgfoid = p.oid limit 1 ) as Trigger_Func, lower(pg_get_functiondef(p.oid) :: text) as def from pg_proc p left join pg_namespace n on p.pronamespace = n.oid left join pg_language l on p.prolang = l.oid left join pg_type t on t.oid = p.prorettype where n.nspname not in ('pg_catalog', 'information_schema') and n.nspname IN ( SELECT n.nspname FROM pg_catalog.pg_namespace n WHERE n.nspname !~ '^pg_' AND n.nspname <> 'information_schema' and n.nspname !~ '^aws_' ) and p.prokind not in ('a', 'w', 'p') and l.lanname in ('sql', 'plpgsql') order by function_schema, function_name ), alias2 as ( select alias1.function_schema, alias1.function_name, alias1.function_language, alias1.Trigger_Func, alias2.* from alias1 cross join lateral ( select i as funcname, cntgroup as cnt from ( select ( regexp_matches( alias1.def, 'aws_[a-z]*_ext[.][a-z]*[_,a-z,$,""]*', 'ig' ) ) [1] i, count(1) cntgroup group by ( regexp_matches( alias1.def, 'aws_[a-z]*_ext[.][a-z]*[_,a-z,$,""]*', 'ig' ) ) [1] ) t ) as alias2 where def ~* 'aws_(oracle|sqlserver|mysql|postgresql)_ext.*' and alias1.Trigger_Func is NULL ) select function_schema as ""DBSchema"", 'Procedural' as ""Category"", 'Standalone-Functions' as ""Sub-Category"", funcname as ""AWS Extension Dependency"", sum(cnt) as ""SCT Function Reference Count"" from alias2 where 1 = 1 group by function_schema, funcname order by 3, 4 desc ) union all ( with alias1 as ( select distinct n.nspname as function_schema, p.proname as function_name, l.lanname as function_language, ( select 'Y' from pg_trigger where tgfoid = p.oid limit 1 ) as Trigger_Func, lower(pg_get_functiondef(p.oid) :: text) as def from pg_proc p left join pg_namespace n on p.pronamespace = n.oid left join pg_language l on p.prolang = l.oid left join pg_type t on t.oid = p.prorettype where n.nspname not in ('pg_catalog', 'information_schema') and n.nspname IN ( SELECT n.nspname FROM pg_catalog.pg_namespace n WHERE n.nspname !~ '^pg_' AND n.nspname <> 'information_schema' and n.nspname !~ '^aws_' ) and p.prokind not in ('a', 'w', 'f') and l.lanname in ('sql', 'plpgsql') order by function_schema, function_name ), alias2 as ( select alias1.function_schema, alias1.function_name, alias1.function_language, alias1.Trigger_Func, alias2.* from alias1 cross join lateral ( select i as funcname, cntgroup as cnt from ( select ( regexp_matches( alias1.def, 'aws_[a-z]*_ext[.][a-z]*[_,a-z,$,""]*', 'ig' ) ) [1] i, count(1) cntgroup group by ( regexp_matches( alias1.def, 'aws_[a-z]*_ext[.][a-z]*[_,a-z,$,""]*', 'ig' ) ) [1] ) t ) as alias2 where def ~* 'aws_(oracle|sqlserver|mysql|postgresql)_ext.*' ) select function_schema as ""DBSchema"", 'Procedural' as ""Category"", 'Standalone - Procedure' as ""Sub-Category"", funcname as ""AWS Extension Dependency"", sum(cnt) as ""SCT Function Reference Count"" from alias2 where 1 = 1 group by function_schema, funcname order by 3, 4 desc ) ) select * from alias1 where ""DBSchema"" IN <<POSTGRES_SCHEMA>>;"
sctassessmentschema,AWS Schema Dependency with Schema Objects,Listing Table with dependency with AWS Schema Conversion Tool,Y,N,N,"with alias1 as ( ( /*Default Constraint*/ with alias1 as ( select alias1.proname, ns.nspname, case when relkind = 'r' then 'TABLE' END AS objType, depend.relname, alias1.proname as def from pg_depend inner join ( select distinct pg_proc.oid as procoid, nspname || '.' || proname as proname, pg_namespace.oid from pg_namespace, pg_proc where nspname in ( 'aws_oracle_ext', 'aws_sqlserver_ext', 'aws_mysql_ext', 'aws_oracle_ext' ) and pg_proc.pronamespace = pg_namespace.oid ) alias1 on pg_depend.refobjid = alias1.procoid inner join pg_attrdef on pg_attrdef.oid = pg_depend.objid inner join pg_class depend on depend.oid = pg_attrdef.adrelid inner join pg_namespace ns on ns.oid = depend.relnamespace where ns.nspname IN ( SELECT n.nspname FROM pg_catalog.pg_namespace n WHERE n.nspname !~ '^pg_' AND n.nspname <> 'information_schema' and n.nspname !~ '^aws_' ) ), alias2 as ( select alias1.nspname as schema, alias1.relname as table_name, alias2.* from alias1 cross join lateral ( select i as funcname, cntgroup as cnt from ( select ( regexp_matches( alias1.def, 'aws_[a-z]*_ext[.][a-z]*[_,a-z,$,""]*', 'ig' ) ) [1] i, count(1) cntgroup group by ( regexp_matches( alias1.def, 'aws_[a-z]*_ext[.][a-z]*[_,a-z,$,""]*', 'ig' ) ) [1] ) t ) as alias2 where ( def ~* 'aws_(oracle|sqlserver|mysql|postgresql)_ext.*' ) ) select alias2.schema as ""DBSchema"", 'Schema' as ""Category"", alias2.table_name as ""DB Schema Obj Name"", 'Default Constraint' as ""Sub - Category"", alias2.funcname as ""AWS Extension Dependency"", sum(cnt) as ""SCT Function Reference Count""   from alias2 group by alias2.schema, alias2.funcname, alias2.table_name union all SELECT n.nspname as ""DBSchema"", 'Schema' as ""Category"", c.relname as ""DB Schema Obj Name"", 'Default Constraint' as ""Sub - Category"", t.funcname as ""AWS Extension Dependency"", sum(t.cnt) as ""SCT Function Reference Count""  FROM pg_attribute a JOIN pg_class c ON c.oid = a.attrelid JOIN pg_namespace n ON n.oid = c.relnamespace LEFT OUTER JOIN pg_attrdef d ON d.adrelid = c.oid AND d.adnum = a.attnum cross join lateral ( select i as funcname, cntgroup as cnt from ( select ( regexp_matches( pg_get_expr(d.adbin, d.adrelid), 'aws_[a-z]*_ext[.][a-z]*[_,a-z,$,""]*', 'ig' ) ) [1] i, count(1) cntgroup group by ( regexp_matches( pg_get_expr(d.adbin, d.adrelid), 'aws_[a-z]*_ext[.][a-z]*[_,a-z,$,""]*', 'ig' ) ) [1] ) t ) t WHERE c.relkind IN ('r', 'v', 'm') AND a.attnum > 0 AND n.nspname NOT IN ('information_schema', 'pg_catalog') and n.nspname !~ '^aws_' AND pg_get_expr(d.adbin, d.adrelid) IS NOT NULL AND EXISTS ( SELECT regexp_matches( pg_get_expr(d.adbin, d.adrelid), 'aws_[a-z]*_ext[.][a-z]*[_,a-z,$,""]*', 'ig' ) ) group by n.nspname, c.relname, t.funcname ) union all ( /*Check Constraint*/ with alias1 as ( select pgc.conname as constraint_name, ccu.table_schema as table_schema, ccu.table_name, ccu.column_name, pg_get_expr(pgc.conbin, cls.oid) as def from pg_constraint pgc join pg_namespace nsp on nsp.oid = pgc.connamespace join pg_class cls on pgc.conrelid = cls.oid left join information_schema.constraint_column_usage ccu on pgc.conname = ccu.constraint_name and nsp.nspname = ccu.constraint_schema where contype = 'c' and nsp.nspname IN ( SELECT n.nspname FROM pg_catalog.pg_namespace n WHERE n.nspname !~ '^pg_' AND n.nspname <> 'information_schema' and n.nspname !~ '^aws_' ) order by pgc.conname ), alias2 as ( select alias1.constraint_name, alias1.table_name, alias1.column_name, alias1.table_schema as schema, alias2.* from alias1 cross join lateral ( select i as funcname, cntgroup as cnt from ( select ( regexp_matches( alias1.def, 'aws_[a-z]*_ext[.][a-z]*[_,a-z,$,""]*', 'ig' ) ) [1] i, count(1) cntgroup group by ( regexp_matches( alias1.def, 'aws_[a-z]*_ext[.][a-z]*[_,a-z,$,""]*', 'ig' ) ) [1] ) t ) as alias2 where def ~* 'aws_(oracle|sqlserver|mysql|postgresql)_ext.*' ) select alias2.schema as ""DBSchema"", 'Schema' as ""Category"", alias2.table_name as  ""Table Name"", 'Check Constraint' as ""Sub - Category"", alias2.funcname as ""AWS Extension Dependency"", sum(cnt) as ""SCT Function Reference Count""  from alias2 group by alias2.schema, alias2.funcname, alias2.table_name ) union all ( with alias1 as ( select alias1.proname, nspname, case when relkind = 'i' then 'INDEX' END AS objType, depend.relname, alias1.proname def from pg_depend inner join ( select distinct pg_proc.oid as procoid, nspname || '.' || proname as proname, pg_namespace.oid from pg_namespace, pg_proc where nspname ~* 'aws_(oracle|sqlserver|mysql|postgresql)_ext.*' and pg_proc.pronamespace = pg_namespace.oid ) alias1 on pg_depend.refobjid = alias1.procoid inner join pg_class depend on depend.oid = pg_depend.objid inner join pg_namespace ns on ns.oid = depend.relnamespace where ns.nspname IN ( SELECT n.nspname FROM pg_catalog.pg_namespace n WHERE n.nspname !~ '^pg_' AND n.nspname <> 'information_schema' and n.nspname !~ '^aws_' ) and relkind = 'i' ), alias2 as ( select alias1.nspname as Schema, alias1.relname as IndexName, alias2.* from alias1 cross join lateral ( select i as funcname, cntgroup as cnt from ( select ( regexp_matches( alias1.def, 'aws_[a-z]*_ext[.][a-z]*[_,a-z,$,""]*', 'ig' ) ) [1] i, count(1) cntgroup group by ( regexp_matches( alias1.def, 'aws_[a-z]*_ext[.][a-z]*[_,a-z,$,""]*', 'ig' ) ) [1] ) t ) as alias2 where def ~* 'aws_(oracle|sqlserver|mysql|postgresql)_ext.*' ) select alias2.schema as ""DBSchema"", 'Schema' as ""Category"", alias2.IndexName as ""Index Name"", 'Index Expression' as ""Sub - Category"", alias2.funcname as ""AWS Extension Dependency"", sum(cnt) as ""SCT Function Reference Count""  from alias2 group by alias2.schema, alias2.funcname, alias2.IndexName ) ) select * from alias1 where ""DBSchema"" IN <<POSTGRES_SCHEMA>> ;"
sctassessmentprocedural,AWS Schema Dependency with Procedural Objects,Listing Procedural with dependency with AWS Schema Conversion Tool,Y,N,N,"with alias1 as ( ( with alias1 as ( select alias1.proname, nspname, case when depend.relkind = 'v' then 'VIEW' END AS objType, depend.relname, pg_get_viewdef(depend.oid) def from pg_depend inner join ( select distinct pg_proc.oid as procoid, nspname || '.' || proname as proname, pg_namespace.oid from pg_namespace, pg_proc where nspname ~* 'aws_(oracle|sqlserver|mysql|postgresql)_ext' and pg_proc.pronamespace = pg_namespace.oid ) alias1 on pg_depend.refobjid = alias1.procoid inner join pg_rewrite on pg_rewrite.oid = pg_depend.objid inner join pg_class depend on depend.oid = pg_rewrite.ev_class inner join pg_namespace ns on ns.oid = depend.relnamespace where not exists ( select 1 from pg_namespace where pg_namespace.oid = depend.relnamespace and nspname !~ '^aws_' ) and nspname IN ( SELECT n.nspname FROM pg_catalog.pg_namespace n WHERE n.nspname !~ '^pg_' AND n.nspname <> 'information_schema' and n.nspname !~ '^aws_' ) ), alias2 as ( select alias1.nspname as Schema, alias1.relname as ViewName, alias2.* from alias1 cross join lateral ( select i as funcname, cntgroup as cnt from ( select ( regexp_matches( alias1.def, 'aws_[a-z]*_ext[.][a-z]*[_,a-z,$,""]*', 'ig' ) ) [1] i, count(1) cntgroup group by ( regexp_matches( alias1.def, 'aws_[a-z]*_ext[.][a-z]*[_,a-z,$,""]*', 'ig' ) ) [1] ) t ) as alias2 where def ~* 'aws_(oracle|sqlserver|mysql|postgresql)_ext.*' ) select alias2.schema as ""DBSchema"", 'Schema' as ""Category"", alias2.ViewName as ""DB Obj Name"", 'Views' as ""Sub-Category"", alias2.funcname as ""AWS Extension Dependency"", sum(cnt) as ""SCT Function Reference Count"" from alias2 group by alias2.schema, alias2.funcname, alias2.ViewName ) union all ( with alias1 as ( select distinct n.nspname as function_schema, p.proname as function_name, l.lanname as function_language, ( select 'Y' from pg_trigger where tgfoid = p.oid limit 1 ) as Trigger_Func, lower(pg_get_functiondef(p.oid) :: text) as def from pg_proc p left join pg_namespace n on p.pronamespace = n.oid left join pg_language l on p.prolang = l.oid left join pg_type t on t.oid = p.prorettype where n.nspname not in ('pg_catalog', 'information_schema') and n.nspname IN ( SELECT n.nspname FROM pg_catalog.pg_namespace n WHERE n.nspname !~ '^pg_' AND n.nspname <> 'information_schema' and n.nspname !~ '^aws_' ) and p.prokind not in ('a', 'w') and l.lanname in ('sql', 'plpgsql') order by function_schema, function_name ), alias2 as ( select alias1.function_schema, alias1.function_name, alias1.function_language, alias1.Trigger_Func, alias2.* from alias1 cross join lateral ( select i as funcname, cntgroup as cnt from ( select ( regexp_matches( alias1.def, 'aws_[a-z]*_ext[.][a-z]*[_,a-z,$,""]*', 'ig' ) ) [1] i, count(1) cntgroup group by ( regexp_matches( alias1.def, 'aws_[a-z]*_ext[.][a-z]*[_,a-z,$,""]*', 'ig' ) ) [1] ) t ) as alias2 where def ~* 'aws_(oracle|sqlserver|mysql|postgresql)_ext.*' and Trigger_Func = 'Y' ) select function_schema as ""DBSchema"", 'Procedural' as ""Category"", alias2.function_name, 'Trigger-Functions' as ""Sub-Category"", funcname as ""AWS Extension Dependency"", sum(cnt) as ""SCT Function Reference Count"" from alias2 where 1 = 1 group by function_schema, funcname, alias2.function_name order by 3, 4 desc ) union all ( with alias1 as ( select distinct n.nspname as function_schema, p.proname as function_name, l.lanname as function_language, ( select 'Y' from pg_trigger where tgfoid = p.oid limit 1 ) as Trigger_Func, lower(pg_get_functiondef(p.oid) :: text) as def from pg_proc p left join pg_namespace n on p.pronamespace = n.oid left join pg_language l on p.prolang = l.oid left join pg_type t on t.oid = p.prorettype where n.nspname not in ('pg_catalog', 'information_schema') and n.nspname IN ( SELECT n.nspname FROM pg_catalog.pg_namespace n WHERE n.nspname !~ '^pg_' AND n.nspname <> 'information_schema' and n.nspname !~ '^aws_' ) and p.prokind not in ('a', 'w', 'p') and l.lanname in ('sql', 'plpgsql') order by function_schema, function_name ), alias2 as ( select alias1.function_schema, alias1.function_name, alias1.function_language, alias1.Trigger_Func, alias2.* from alias1 cross join lateral ( select i as funcname, cntgroup as cnt from ( select ( regexp_matches( alias1.def, 'aws_[a-z]*_ext[.][a-z]*[_,a-z,$,""]*', 'ig' ) ) [1] i, count(1) cntgroup group by ( regexp_matches( alias1.def, 'aws_[a-z]*_ext[.][a-z]*[_,a-z,$,""]*', 'ig' ) ) [1] ) t ) as alias2 where def ~* 'aws_(oracle|sqlserver|mysql|postgresql)_ext.*' and alias1.Trigger_Func is NULL ) select function_schema as ""DBSchema"", 'Procedural' as ""Category"", alias2.function_name, 'Standalone-Functions' as ""Sub-Category"", funcname as ""AWS Extension Dependency"", sum(cnt) as ""SCT Function Reference Count"" from alias2 where 1 = 1 group by function_schema, funcname, alias2.function_name order by 3, 4 desc ) union all ( with alias1 as ( select distinct n.nspname as function_schema, p.proname as function_name, l.lanname as function_language, ( select 'Y' from pg_trigger where tgfoid = p.oid limit 1 ) as Trigger_Func, lower(pg_get_functiondef(p.oid) :: text) as def from pg_proc p left join pg_namespace n on p.pronamespace = n.oid left join pg_language l on p.prolang = l.oid left join pg_type t on t.oid = p.prorettype where n.nspname not in ('pg_catalog', 'information_schema') and n.nspname IN ( SELECT n.nspname FROM pg_catalog.pg_namespace n WHERE n.nspname !~ '^pg_' AND n.nspname <> 'information_schema' and n.nspname !~ '^aws_' ) and p.prokind not in ('a', 'w', 'f') and l.lanname in ('sql', 'plpgsql') order by function_schema, function_name ), alias2 as ( select alias1.function_schema, alias1.function_name, alias1.function_language, alias1.Trigger_Func, alias2.* from alias1 cross join lateral ( select i as funcname, cntgroup as cnt from ( select ( regexp_matches( alias1.def, 'aws_[a-z]*_ext[.][a-z]*[_,a-z,$,""]*', 'ig' ) ) [1] i, count(1) cntgroup group by ( regexp_matches( alias1.def, 'aws_[a-z]*_ext[.][a-z]*[_,a-z,$,""]*', 'ig' ) ) [1] ) t ) as alias2 where def ~* 'aws_(oracle|sqlserver|mysql|postgresql)_ext.*' ) select function_schema as ""DBSchema"", 'Procedural' as ""Category"", alias2.function_name, 'Standalone - Procedure' as ""Sub-Category"", funcname as ""AWS Extension Dependency"", sum(cnt) as ""SCT Function Reference Count"" from alias2 where 1 = 1 group by function_schema, funcname, function_name order by 3, 4 desc ) ) select * from alias1 where ""DBSchema"" IN <<POSTGRES_SCHEMA>>;"
